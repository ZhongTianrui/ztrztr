# 题面

## 题目描述

Darko 组织了一场比赛，有 $n$ 名选手参加，编号为 $1 \sim n$，现在还差最后一个阶段的成绩没有公布

已知在最后一个阶段的成绩公布之前，$i$ 号选手的得分为 $a_i$，$i$ 号选手在最后一阶段的得分会是 $[L_i, R_i]$ 范围内的整数（即 $L_i \leq $ 他最后一阶段的得分 $\leq R_i$），将最后一阶段的得分加进 $a_i$ 里就可以得到这位选手这场比赛的最终得分

当比赛结束时，Darko 将对各位选手进行按最终得分进行排名，最终得分最高的为第 $1$ 名，第 $2$ 高的为第 $2$ 名，以此类推，得分相同的排名并列，排名为所有选手中比该选手得分高的人数 $+1$

举例：如果有 $5$ 名选手，最终得分为 $3, 3, 2, 2, 1$，则他们的排名分别为 $1, 1, 3, 3, 5$

现在请你对 $1 \sim n$ 号选手分别计算，当比赛结束时该选手可能的最高排名和最低排名分别是多少

## 输入格式

第一行，包含一个正整数 $n$

第二行，包含 $n$ 个正整数 $a_i$，分别表示每位选手在最后一个阶段的成绩公布之前的得分

接下来 $n$ 行，每行包含 $2$ 个正整数 $L_i, R_i$，依次表示每位选手在最后一阶段的得分的范围

## 输出格式

输出 $n$ 行，每行包含两个正整数，用空格隔开，依次表示每位选手在比赛结束时可能的最高排名和最低排名

## 样例 #1

### 样例输入 #1

```
5
2 4 10 8 6
1 10
2 9
3 8
4 7
5 6
```

### 样例输出 #1

```
2 5
1 5
1 2
1 3
2 5
```

## 提示

### 数据范围

对于 $60\%$ 的数据，$1 \leq n \leq 1000$

对于 $100\%$ 的数据，$1 \leq n \leq 10^5, 1 \leq a_i \leq 10^9, 1 \leq L_i \leq R_i \leq 10^9$



# 思路

首先排序从高到低，用 `greater<int>{}`，lower_bownd 也用同样的方法，从高到低地找。

对于每个选手，最高的排名就是自己加 $r_i$，其他人加 $l_i$；最低排名就是自己加 $l_i$，其他人家 $r_i$。

代码：

```cpp
#include <bits/stdc++.h>

using namespace std;
int a[100005], b[100005], c[100005], f[100005], n, L[100005], R[100005];
int main() {
    ios::sync_with_stdio(false); cin.tie(0); cout.tie(0);
    cin >> n;
    for (int i = 1; i <= n; i ++) {
        cin >> a[i];
        f[i] = a[i];
    }
    sort(a + 1, a + n + 1);
    for (int i = 1; i <= n; i ++) {
        int l, r;
        cin >> l >> r;
        b[i] = f[i] + l;
        L[i] = b[i];
        c[i] = f[i] + r;
        R[i] = c[i];
    }
    sort(b + 1, b + n + 1, greater<int>{});
    sort(c + 1, c + n + 1, greater<int>{});
    // for (int i = 1; i <= n; i ++) {
    //     cout << a[i] << " " << b[i] << " " << c[i] << " " << f[i] << "\n";
    // }
    for (int i = 1; i <= n; i ++) 
        cout << (lower_bound(b + 1, b + n + 1, R[i], greater<int>{}) - b) << " " << (lower_bound(c + 1, c + n + 1, L[i], greater<int>{}) - c - (L[i] != R[i])) << "\n";
    return 0;
}
```

