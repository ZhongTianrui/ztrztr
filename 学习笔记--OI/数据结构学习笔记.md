# 数据结构基础的学习笔记

## 前言

编程 = 算法 + 数据结构。

数据结构是信息竞赛中的重要的一部分，有了数据结构才能有算法，如果只有算法，但是无法实现，那么这个算法就没有用了。

当然，算法也是很重要的，即使学习了数据结构但是不会使用也就是不会算法，那么也无法解决很多题目。

## 1.0 线性结构

线性结构顾名思义，就是一种排列为线性的数据结构。

这种数据结构的逻辑位置是连续的，不会分叉的。

比如说时间就是一种线性的结构，只会连续，不会分叉。

线性结构常用的有数组和链表.

这个章节记录的关键：

数组和链表，栈和队列，$\LARGE{\color{red}{卡特兰数}}$。

卡特兰数：对于 n 个不同元素入栈，出栈的可能情况有：
$$
f(x) = \frac{{C}_{2n}^{n}}{n + 1}
$$
对于 n 个元素组成的二叉树的个数也是 $f(x)$。

### 1.0.1 数组

数组，是一种物理和逻辑都是连续的结构，如果一个元素在数组里面的逻辑顺序是最后一个，那么物理顺序也是最后的。

数组不一定只能装数，还可以装字符串等其他数据。

在原生 c++ 中，我们一般用 `<typeName> a[<LENGTH>]` 来定义一个数组。

在 STL 中，还有 `vector` 和 `array(不常用)` 来定义。

数组的访问不需要迭代器，直接通过下标就可以访问。

这种数据结构的优点在于：

1. 遍历方便，直接按顺序遍历就行。
2. 查询方便，可以下标查询。

但是删除和插入就不那么方便了，时间复杂度最高会达到 $O(n)$，这是比较不可接受的。

如果用原生的数组，求和也会达到 $O(n)$，解决方法就是用前缀和（具体见`前缀和笔记`）。

### 1.0.2 链表

链表，是一种逻辑位置连续，但是物理位置不一定连续的数据结构。

链表的实现方法有两种，数组实现和指针实现。

数组实现的方法就是定义两个数组，一个存储数据，一个存储指针。对于任意一个节点询问下一个节点的方法就是访问 `a[next[i]]`。

指针的方法就是最直接的，定义结构体指针：

```cpp
struct linkList{
    <dataTypeName> data;
    *linkList nxt;
}
```

### 1.0.3 栈

栈这种数据结构，具有先进后出的原则（FILO）。

栈大约是这样：

```
| 1 | --top = 3
-----
| 2 |
-----
| 3 |
-----
```

实现方法就是用一个数组维护数据，再定义一个 top 指针指向数组的顶部。

```cpp
struct Stack{
    <dataTypeName> data[<maxArrayLength>];
    int top = 0;
    void insert(int x) {
        data[++ top] = x;
    }
    //不确定是否可以通过编译
}
```

### 1.0.4 队列

队列是先进先出的，FIFO

直接用 stl 的队列，这里不写了（太懒）

### 1.0.5 扩展

CSP -J 里面一般 T4 会考数据结构和 dp，数据结构主要就是这两种。

在看见题目的时候，我们会从一下几个角度去分析：

1. 可以维护题目的数据结构有哪些，一一列出来。比如如果需要维护 fifo，那么是队列或者队列的扩展。
2. 根据题目的特性和数据结构判断是啥算法。

#### 1.0.5.1 优先队列

优先队列，可以自动实现自动对队列元素进行排序，保证队列里面是单调的，但不用踢出元素。

这个数据结构是由大根堆维护的。

一般在考场上我们不会自己手写有限队列，因为码量大，而且很容易出错，我们一般用 STL 里面的 $\text{priority\_queue}$ 来实现。

### 2.0 树

一种非线性数据结构。

树的定义是：

对于一个任意两点有且只有一条路的联通图，我们称之为树。

这里主要写二叉树。

### 2.0.1 二叉树

二叉树，一般写作 `BiTree`，定义为：

对于任意一颗有根树，如果任意节点的子节点数量都小于等于 $2$，那么这棵树就是一个二叉树。

对于一个线性结构，这个结构的逻辑也是线性的，存储很方便。

但是如果存储二叉树，我们也只能用数组，常用的有以下表示法：

1. **数组表示法**：这个方法运用了数学的方法，对于一颗二叉树，设根的编号为 $x$，那么左子树和右子树的下标分别是 $x \times 2$ 和 $x \times 2 + 1$。这种方法比较适合完全二叉树。

2. **二叉链**：这种方法对所有二叉树都通用。定义一个结构体，包含前驱指向父亲节点，左右孩子指针指向左右孩子，还有一个变量存放数据。

   如果这个节点是根节点，那么没有前驱。如果这个节点是叶子节点，那么没有左右孩子。

   我不太喜欢指针所以用三个数组代替，跟链表的数组表示法一样。

3. **父亲表示法**：这种方法不适合遍历，适合从下往上找。

   对于最近公共祖宗的题目，可以用这个方法存储。

   顾名思义，父亲表示法就是定义数组表示一个节点的父亲，每次递归父亲节点去往上查找。

二叉树的遍历方式有前序遍历、中序遍历和后序遍历。

前序遍历：遍历方式是：根，左，右。

中序遍历：左，根，右。

后序遍历：左，右，根。

其他：

对于 $n$ 个节点的二叉树有
$$
f(x) = \frac{{C}_{2n}^{n}}{n + 1}
$$
种形态，也就是卡特兰数。

### 2.0.2 基础二叉搜索树

二叉查找树是一种方便查找的树，可以自动排序，插入、查询、删除的平均复杂度都是 $O(\log n)$。

二叉查找树的定义是：

对于任意子树，都要保证左子树 < 根 < 右子树。

#### 实现插入：

- 若二叉搜索树是空树，则插入一个数据为X 的结点作为根结点并返回根结点给双亲结点(如果存在的话)，否则：
- 将根结点的数据域值与X进行比较，搜索合适的插入位置：
  - 若X**小于**根结点的数据域值，则只需在其左子树继续搜索；
  - 若X**大于**根结点的数据域值，则只需在其右子树继续搜索；
  - 若X**等于**根结点的数据域值，无需处理，结束插入程序；
- 重复上述过程

代码：

#### 实现查找

- 查找从根结点开始，若二叉搜索树为空，则返回空，否则
- 将根结点的数据域值与X进行比较，并进行相应的处理：
  - 若X**等于**根结点的数据域值，搜索完成，返回该结点；
  - 若X**小于**根结点的数据域值，则只需在其左子树继续搜索；
  - 若X**大于**根结点的数据域值，则只需在其右子树继续搜索；
- 重复上述过程

#### 整体代码

```cpp
#include <bits/stdc++.h>

using namespace std;
int a[10000005], n;
void insert(int x, int i) {
	if (a[i] == -1) {
		a[i] = x;
		return;
	}
	if (x < a[i]) {
		insert(x, i * 2);
	} else if (x > a[i]) {
		insert(x, i * 2 + 1);
	}
}
int find(int x, int i, int ch) {
	if (a[i] == x) {
		return ch;
	}
	if (x < a[i]) {
		find(x, i * 2, ch + 1);
	} else if (x > a[i]) {
		find(x, i * 2 + 1, ch + 1);
	}
}
int main() {
	// ios::sync_with_stdio(false); cin.tie(0); cout.tie(0);
	memset(a, -1, sizeof(a));
	cin >> n;
	for (int i = 1; i <= n; i ++) {
		int x; cin >> x;
		insert(x, 1);
	}
	int m; cin >> m;
	while (m --) {
		int x; cin >> x;
		cout << find(x, 1, 1);
	}
	return 0;
}
```
